#!/usr/bin/env python

# Copyright 2012-2013 James Geboski <jgeboski@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import argparse
import logging
import os
import string
import sys
import time

# Temporarily set the path for testing
sys.path.append("../")

from mctl.config import Config
from mctl.server import Server
from mctl.util   import fopen

def parseargs():
    parser = argparse.ArgumentParser(
        description = "Minecraft server controller"
    )

    parser.add_argument(
        "-g", "--config",
        required = False,
        type     = str,
        action   = "store",
        dest     = "config",
        metavar  = "PATH",
        help     = "specify a nonstandard config file"
    )

    parser.add_argument(
        "-s", "--server",
        required = True,
        type     = str,
        action   = "store",
        dest     = "server",
        metavar  = "SERVER",
        help     = "server to apply actions and attributes to"
    )

    parser.add_argument(
        "-l", "--list",
        required = False,
        action   = "store_true",
        dest     = "list",
        help     = "list the current servers"
    )

    parser.add_argument(
        "-f", "--force",
        required = False,
        action   = "store_true",
        dest     = "force",
        help     = "force specified actions"
    )

    parser.add_argument(
        "-d", "--dry-run",
        required = False,
        action   = "store_true",
        dest     = "dryrun",
        help     = "run on a trial basis; do not modify packages"
    )

    parser.add_argument(
        "-u", "--upgrade",
        required = False,
        action   = "store_true",
        dest     = "upgrade",
        help     = "upgrade the server packages"
    )

    parser.add_argument(
        "-i", "--start",
        required = False,
        action   = "store_true",
        dest     = "start",
        help     = "start the sever"
    )

    parser.add_argument(
        "-q", "--stop",
        required = False,
        action   = "store_true",
        dest     = "stop",
        help     = "stop the sever"
    )

    parser.add_argument(
        "-r", "--restart",
        required = False,
        action   = "store_true",
        dest     = "restart",
        help     = "restart the sever"
    )

    parser.add_argument(
        "-c", "--command",
        required = False,
        type     = str,
        action   = "store",
        dest     = "command",
        metavar  = "COMMAND",
        help     = "run a command on the server"
    )

    parser.add_argument(
        "--include",
        required = False,
        type     = str,
        action   = "store",
        dest     = "include",
        metavar  = "LIST",
        help     = "list packages to include"
    )

    parser.add_argument(
        "--exclude",
        required = False,
        type     = str,
        action   = "store",
        dest     = "exclude",
        metavar  = "LIST",
        help     = "list packages to exclude"
    )

    parser.add_argument(
        "--message",
        required = False,
        type     = str,
        action   = "store",
        dest     = "message",
        metavar  = "MESSAGE",
        help     = "message for restart/stop"
    )

    parser.add_argument(
        "--timeout",
        required = False,
        type     = int,
        action   = "store",
        dest     = "timeout",
        metavar  = "TIMEOUT",
        help     = "server shutdown timeout in seconds"
    )

    return parser.parse_args()

def main():
    args   = parseargs()
    config = Config(args.config)
    log    = logging.getLogger("mctl")

    logging.basicConfig(format = "[%(levelname)s] %(message)s")
    log.setLevel(logging.INFO)
    config.load()

    server  = None
    package = None

    if args.list:
        servers = config.servers_get()
        servers = servers.keys()

        if len(servers) < 1:
            print "No servers found"

        print "Server(s): %s" % (string.join(servers, ", "))
        return 0

    if not config.server_exists(args.server):
        log.error("%s: invalid server name", args.server)
        return 1

    server = config.server_get(args.server)

    if args.timeout:
        server['timeout'] = int(args.timeout)

    config.server_set(args.server, server)
    server = Server(args.server, server)

    if args.dryrun:
        if args.upgrade:
            server.upgrade(config, args.force, args.include, args.exclude, True)
        return 0

    lfh = os.path.join(server.path, "mctl.log")
    lfh = logging.FileHandler(lfh)
    fmt = logging.Formatter("%(asctime)s [%(levelname)s] %(message)s",
                            "%y-%m-%d %H:%M:%S")

    lfh.setFormatter(fmt)
    log.addHandler(lfh)

    msg = "** MCTL: %s" % (string.join(sys.argv))
    rcd = log.makeRecord(log.name, logging.INFO, None, 0, msg, None, None)
    lfh.emit(rcd)

    if args.restart:
        args.stop = args.start = True

    if args.stop:
        server.stop(args.message)

    if args.upgrade:
        server.upgrade(config, args.force, args.include, args.exclude, False)

    if args.start:
        server.start(args.force)

    if args.command:
        server.command(args.command)

    lfh.stream.write(os.linesep)
    lfh.close()
    return 0

if __name__ == "__main__":
    exit(main())
