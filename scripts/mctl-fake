#!/usr/bin/env python

import asyncore
import logging
import optparse
import os
import signal
import sys

# Temporarily set the path for testing
sys.path.append("../mctl")

from server import FakeServer
from signal import signal, SIGINT, SIGQUIT, SIGTERM

parser = optparse.OptionParser(
    usage       = "usage: %prog [OPTIONS]",
    description = "Minecraft fake server"
)

acts  = optparse.OptionGroup(parser, "Server Actions")
attrs = optparse.OptionGroup(parser, "Server Attributes")

parser.add_option(
    "-s", "--server",
    action  = "store",
    dest    = "server",
    metavar = "SERVER",
    help    = "server to apply actions and attributes to"
)
parser.add_option(
    "-k", "--kill",
    action  = "store_true",
    dest    = "kill",
    help    = "kill the server"
)

attrs.add_option(
    "--addr",
    action  = "store",
    dest    = "addr",
    metavar = "ADDRESS",
    help    = "address to bind to and listen on"
)
attrs.add_option(
    "--port",
    action  = "store",
    dest    = "port",
    metavar = "PORT",
    help    = "the port to bind to and listen on"
)
attrs.add_option(
    "--motd",
    action  = "store",
    dest    = "motd",
    metavar = "MOTD",
    help    = "Message of The Day to display"
)
attrs.add_option(
    "--message",
    action  = "store",
    dest    = "message",
    metavar = "MESSAGE",
    help    = "message to display on kick"
)

parser.add_option_group(acts)
parser.add_option_group(attrs)

opts, args = parser.parse_args()

logging.basicConfig(format = "[%(levelname)s] %(message)s")

log = logging.getLogger("mctl")
log.setLevel(logging.INFO)

if not opts.server:
    parser.error("option -s, --server is required")
    exit(1)

if opts.kill:
    if FakeServer.kill(opts.server):
        exit()
    
    exit(1)

pidfile = FakeServer.pidfile(opts.server)
pidpath = os.path.dirname(pidfile)

pid = os.getpid()
run = True

def handler(signum, frame):
    global run
    run = False

signal(SIGINT,  handler)
#signal(SIGQUIT, handler)
#signal(SIGTERM, handler)

if not os.path.isfile(pidpath):
    try:
        os.makedirs(pidpath)
    except os.error, msg:
        log.error("Unable to create path: %s: %s", pidpath, msg)
        exit(1)

try:
    fp = open(pidfile, "w")
except IOError, msg:
    log.error("Unable to open: %s: %s", pidfile, msg)
    exit(1)

fp.write(str(pid))
fp.close()

opts.port = int(opts.port) if opts.port else None
server    = FakeServer(opts.addr, opts.port, opts.motd, opts.message)

while run:
    asyncore.loop(10, False, None, 1)

server.close()
os.remove(pidfile)
