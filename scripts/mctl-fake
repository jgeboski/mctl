#!/usr/bin/env python

# Copyright 2012-2013 James Geboski <jgeboski@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import asyncore
import logging
import optparse
import os
import signal
import sys

# Temporarily set the path for testing
sys.path.append("../")

from mctl.fakeserver import FakeServer, mcclients
from mctl.util       import fopen, unlink
from signal          import signal, SIGINT

parser = optparse.OptionParser(
    usage       = "usage: %prog [OPTIONS]",
    description = "Minecraft fake server"
)

acts  = optparse.OptionGroup(parser, "Server Actions")
attrs = optparse.OptionGroup(parser, "Server Attributes")

parser.add_option(
    "-s", "--server",
    action  = "store",
    dest    = "server",
    metavar = "SERVER",
    help    = "server to apply actions and attributes to"
)

acts.add_option(
    "-f", "--foreground",
    action  = "store_true",
    dest    = "foreground",
    help    = "do not fork into a screen session"
)
acts.add_option(
    "-k", "--kill",
    action  = "store_true",
    dest    = "kill",
    help    = "kill the server"
)
attrs.add_option(
    "--version-list",
    action  = "store_true",
    dest    = "version_list",
    help    = "print a list of supported protocol versions"
)

attrs.add_option(
    "--addr",
    action  = "store",
    dest    = "addr",
    metavar = "ADDRESS",
    help    = "address to bind to and listen on"
)
attrs.add_option(
    "--port",
    action  = "store",
    dest    = "port",
    metavar = "PORT",
    help    = "port to bind to and listen on"
)
attrs.add_option(
    "--version",
    action  = "store",
    dest    = "version",
    metavar = "VERSIONID",
    help    = "version of the Minecraft protocol to use"
)
attrs.add_option(
    "--motd",
    action  = "store",
    dest    = "motd",
    metavar = "MOTD",
    help    = "message of The Day to display"
)
attrs.add_option(
    "--message",
    action  = "store",
    dest    = "message",
    metavar = "MESSAGE",
    help    = "message to display on kick"
)

parser.add_option_group(acts)
parser.add_option_group(attrs)

opts, args = parser.parse_args()

logging.basicConfig(format = "[%(levelname)s] %(message)s")

log = logging.getLogger("mctl")
log.setLevel(logging.INFO)

if opts.version_list:
    print "Minecraft versions:"

    for ver, sver in mcclients.items():
        print "  %s: %d" % (sver, ver)

    print ""
    exit()

if not opts.server:
    parser.error("option -s, --server is required")
    exit(1)

if opts.kill:
    if FakeServer.kill(opts.server):
        exit()

    exit(1)

if FakeServer.running(opts.server):
    log.error("%s: failed to start: fake server is running", opts.server)
    exit(1)

if not opts.foreground:
    FakeServer.fork(opts.server, opts.addr, opts.port, opts.version, opts.motd,
                    opts.message)
    exit()

pidfile = FakeServer.pidfile(opts.server)
pid     = os.getpid()
run     = True

def handler(signum, frame):
    global run
    run = False

signal(SIGINT,  handler)

fp = fopen(pidfile, "w", True)

if not fp:
    exit(1)

fp.write(str(pid))
fp.close()

server = FakeServer(opts.addr, opts.port, opts.version, opts.motd, opts.message)

while run:
    asyncore.loop(10, False, None, 1)

server.close()
unlink(pidfile)
